/*****************************************************************************           c ''''''''''''''''''''''''''''''''''''''''''''''''' c         c  cccccccccccccccccccccccccc cccccccccccccccccccccccc  c        c  ccc@@@@cccc@@@@cc@ccc@ccc@c ccc    ccc    cccc    ccc  c       c  ccc@cccc@cc@ccc@@c@ccc@ccc@c cc cccc c cccc cc cccc ccc  c       c  ccc@cccc@c@ccc@@cc@ccc@ccc@c c cccccc cccccc c cccc ccc  c       c  ccc@cccc@cc@cccccc@ccc@ccc@c cc cccc c cccc cc cccc ccc  c        c  cc@cccc@ccc@@@@ccc@@@c@@@cc ccc    ccc    ccc ccc ccc  c         c  cccccccccccccccccccccccccccccccccccccccccccc cccccc  c           c ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, c© NewLoop Ltd: 020 7702 3130Author Lindsey Fallow: lindz@btinternet.com****************************************************************************                       CLASS DESCRIPTION AND DEFINITION            *                                                     *                      *                                                     *                      *                                                     *                      *                                                     *                      *                                                     *                      *                                                     *                      *                                                     *                      *                                                     *          ****************************************************************************        Code Conventions:        Class        verbMethod        nounProperty        _nounProperty = simple property relating directly to MovieClip properties (height, width etc)        isBoolean        onCallback        _mc = MovieClip        _txt = TextField        _arr = Array        _str = String        tVariableName = temporary variable for calculation or data handling purposes*****************************************************************************/package com.newloop.air{	import com.newloop.air.events.AirUpdateManagerEvent;		import com.yahoo.astra.fl.managers.AlertManager;		import com.deng.fzip.FZip;	import com.deng.fzip.FZipErrorEvent;	import com.deng.fzip.FZipEvent;	import com.deng.fzip.FZipFile;		import fl.controls.Button;		import flash.display.DisplayObject;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.events.MouseEvent;	import flash.filesystem.File;	import flash.filesystem.FileMode;	import flash.filesystem.FileStream;	import flash.net.URLLoader;	import flash.net.URLLoaderDataFormat;	import flash.net.URLRequest;		import flash.utils.ByteArray;		//import mx.controls.Alert;	//import mx.events.CloseEvent;					/**	 * AirUpdateManager handles compulsory and optional updates to Air Applications	 * 	 * <p>The class relies on a remote xml file containing the version information.</p>	 * <p>The structure of the remote xml file is : </p>	 * <p><code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;<br>	 * &lt;currentVersion&gt;<br>	 * &lt;version&gt;2.2&lt;/version&gt;<br>	 * &lt;downloadLocation&gt;&lt;![CDATA[http://www.yourdomain.com/AIR/UMTest/UM.air]]&gt;&lt;/downloadLocation&gt;<br>     * &lt;forceUpdate&gt;false&lt;/forceUpdate&gt;<br>     * &lt;message&gt;&lt;![CDATA[Added new features]]&gt;&lt;/message&gt;<br>     * &lt;/currentVersion&gt;</code></p>	 * 	 * @author lindseyf	 * 	 */		public class AirResourceUpdateManager extends EventDispatcher	{				private var downloadLocation:String;		private var localPath:String;		private var filename:String;		private var displayTarget:DisplayObject;		private var file:File;		private var zip:FZip;		private var directoryPath:String;		private var targetDirectory:File;		private var isDownloadError:Boolean;						/**		 * Creates a new AirUpdateManager instance.  After creating the AirUpdateManager listen for the AirUpdateManagerEvent events.		 * 		 * @param displayTargetObj - A display object to be used as the container for the alert.		 * @param versionXmlUrl - The path to the version.xml file. 		 * @param isAutoCheck - If true, the update manager performs the check immediately.		 * 		 */				public function AirResourceUpdateManager(displayTargetObj:DisplayObject, directoryPath:String, filename:String, localPath:String, downloadLocation:String, createSymbolicLink:Boolean = true)		{					// localise stuff for PC / Mac						this.displayTarget = displayTargetObj;			this.localPath = localPath;			this.targetDirectory = this.resolvePath("");			this.createRequiredDirectories(directoryPath);			this.targetDirectory = this.resolvePath(directoryPath);			this.filename = filename;			this.downloadLocation = downloadLocation;			this.isDownloadError = false;		}				/**		 * Checks whether the file is already available. 		 * 		 * @param isAutoDownload - specifies whether to proceed to offer download if the file is not found.		 * @param downloadDialogMessage - message to show the user in offering the file download.		 * 		 * @return Boolean		 */						public function checkForFile(isAutoDownload:Boolean = true, downloadDialogMessage:String = "Would you like to download this file?"):Boolean{			// resolve the local file path			this.file = this.targetDirectory.resolvePath(this.filename);			//			trace("this.file : " + this.file.toString());			if(this.file.exists){				return true;			} else {				if(isAutoDownload){					this.displayDialog(downloadDialogMessage);					}				return false;			}		}								private function displayDialog(downloadDialogMessage:String):void{			trace("display update dialog");			var buttonArray:Array = ["Later", "Download"];			var alertTitle:String = "Download available";						AlertManager.createAlert(this.displayTarget, downloadDialogMessage, alertTitle, buttonArray, this.alertHandler);					}				private function alertHandler(e:MouseEvent):void{			var btn:Button = e.currentTarget as Button;			trace("btn : " + btn);			var choice:String = btn.name;						if(choice=="Download"){			 	// run the update			 	this.runUpdate();			} else {				// run the handler function				this.cancelUpdate();			}		}						private function runUpdate():void{			var e:AirUpdateManagerEvent = new AirUpdateManagerEvent(AirUpdateManagerEvent.ACCEPT_UPDATE);			this.dispatchEvent(e);			this.downloadFile();		}				private function cancelUpdate():void {			trace("cancelUpdate");						var e:AirUpdateManagerEvent = new AirUpdateManagerEvent(AirUpdateManagerEvent.SKIP_UPDATE);						this.dispatchEvent(e);		}				public function downloadFile():void {			trace("downloading file : " + this.downloadLocation);						var request:URLRequest = new URLRequest(this.downloadLocation);						if(this.downloadLocation.split(".").pop() == "zip"){				this.downloadZip(request);				return;			}						var loader:URLLoader = new URLLoader();			loader.dataFormat = URLLoaderDataFormat.BINARY;			loader.load(request);			loader.addEventListener(Event.COMPLETE, this.writeFileToSystem);			loader.addEventListener(ProgressEvent.PROGRESS, this.updateProgressHandler);			loader.addEventListener(IOErrorEvent.IO_ERROR, this.IOLoaderErrorHandler);		}				private function downloadZip(request:URLRequest):void {			trace("download zip");			this.zip = new FZip();			this.zip.addEventListener(Event.COMPLETE, this.zipCompleteHandler);			this.zip.addEventListener(IOErrorEvent.IO_ERROR, this.IOZipErrorHandler);			this.zip.addEventListener(FZipErrorEvent.PARSE_ERROR, this.parseErrorHandler);			this.zip.addEventListener(ProgressEvent.PROGRESS, this.updateProgressHandler);			this.zip.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.securityErrorHandler);			this.zip.addEventListener(Event.OPEN, defaultHandler);			this.zip.addEventListener(FZipEvent.FILE_LOADED, this.fileLoadedHandler);						this.zip.load(request);		}				private function fileLoadedHandler(e:FZipEvent):void{			var tFile:FZipFile = e.file;			trace("file loaded : " +tFile.filename);			// write file			this.writeZipFileToSystem(tFile);		}				private function defaultHandler(e:Event):void{			trace("defaultHandler : " + e.type);			this.dispatchEvent(e.clone());		}				private function zipCompleteHandler(e:Event):void {			trace("zip complete handler");			//this.writeZipFolderToSystem();			if(!this.isDownloadError){				this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_COMPLETE));			}					}				private function parseErrorHandler(e:Event):void{			this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "Error in zip parsing."));		}				private function IOZipErrorHandler(e:Event):void{			this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "IOError in zip processing."));		}				private function IOLoaderErrorHandler(e:Event):void{			this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "IOError in loader - unable to download files."));		}				private function securityErrorHandler(e:Event):void{			this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "Security error in zip parsing."));		}				private function writeZipFolderToSystem():void{			trace("write zip folder to system");			var stream:FileStream = new FileStream();						var tFolderArr:Array = this.filename.split("/");			tFolderArr.pop();			var folderPath:String = tFolderArr.join("/");						var folderLocation:String = this.localPath + folderPath;			this.file = this.targetDirectory.resolvePath(folderLocation);			trace("writing : " +this.file.nativePath);			try{				// open and write to the file stream				stream.open(this.file, FileMode.WRITE);				this.zip.serialize(stream);				stream.close();				//				this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_COMPLETE));				trace("wrote file");			} catch (error:Error) {				trace('failed to write: ' + error);				this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "Failed to write zip folder to system."));			}		}				private function writeZipFileToSystem(tFile:FZipFile):void{			trace("write zip file to system");			var stream:FileStream = new FileStream();						this.createRequiredDirectories(tFile.filename);						var fileToWrite:File = this.targetDirectory.resolvePath(tFile.filename);			trace("writing : " +fileToWrite.nativePath);			if(fileToWrite.isDirectory){				return;			}			try{				// open and write to the file stream				stream.open(fileToWrite, FileMode.WRITE);				var contentByteArray:ByteArray = tFile.content;				stream.writeBytes(contentByteArray);				stream.close();				//				//if(this.isDownloadComplete){					//this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_COMPLETE));				//}				trace("wrote file");			} catch (error:Error) {				trace('failed to write: ' + error);				this.isDownloadError = true;				this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "Failed to write zip file to system."));			}		}				private function createRequiredDirectories(fileDirectory:String):void{			// recurse through the director path to create any required folders			var directoryArray:Array = fileDirectory.split("/");			// check each exists			var workingDirectory:File = this.targetDirectory;			var iLength:uint = directoryArray.length-1;			for(var i:uint = 0;i<iLength;i++){				trace("working directory : " + workingDirectory.nativePath);				var directoryName:String = directoryArray[i];				trace("directoryName : " + directoryName);				var nextWorkingDirectory:File = workingDirectory.resolvePath(directoryName);				if(nextWorkingDirectory.exists){					if(nextWorkingDirectory.isDirectory){						// do nothing						trace("directory exists");					} else {						// error!						trace("file not a directory");						this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "Expected directory, but path is to a file."));					}				} else {					trace("folder not found");					var newDir:File = File.createTempDirectory();					var nextWorkingDirectoryProxy:File = newDir.resolvePath(directoryName);					nextWorkingDirectoryProxy.createDirectory();					nextWorkingDirectoryProxy.copyTo(nextWorkingDirectory);				}				workingDirectory = nextWorkingDirectory;				trace(workingDirectory.nativePath);			}			//		}						private function writeFileToSystem(e:Event):void {			trace("writing file");			//return;			try {				// get the last bit of the file path - this is the file name				var filename:String = this.downloadLocation.split("/").pop() as String;				var stream:FileStream = new FileStream();				stream.open(this.file, FileMode.WRITE);				stream.writeBytes(e.target.data);				stream.close();				this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_COMPLETE));				trace("wrote file");			} catch (error:Error) {				trace('failed to write: ' + error);				this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "Failed to write file to system"));			}		}				private function updateProgressHandler(e:ProgressEvent):void{						var percentage:Number = Math.round(100*(e.bytesLoaded / e.bytesTotal));			trace("percentage : " + percentage);			this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_PROGRESS,percentage));		}				private function resolvePath(fileOrFolderName:String):File{			var tFile:File;			if( this.localPath == "documentsDirectory"){				tFile = File.documentsDirectory.resolvePath(fileOrFolderName);				} else if (this.localPath == "applicationDirectory"){				tFile = File.applicationDirectory.resolvePath(fileOrFolderName);			} else if(this.localPath == "applicationParentDirectory"){				tFile = File.applicationDirectory;				tFile = tFile.resolvePath("..");				tFile = tFile.resolvePath(fileOrFolderName);			} else if(this.localPath == "applicationStorageDirectory"){				tFile = File.applicationStorageDirectory.resolvePath(fileOrFolderName);			} else if(this.localPath == "desktopDirectory"){				tFile = File.desktopDirectory.resolvePath(fileOrFolderName);			} else if(this.localPath == "userDirectory"){				tFile = File.userDirectory.resolvePath(fileOrFolderName);			} else {				tFile = null;				this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "Unresolvable folder path."));			}			trace("tFile : " + tFile.nativePath);						return tFile;		}			}}