/* Copyright (c) <2009> <Newloop>Permission is hereby granted, free of charge, to any personobtaining a copy of this software and associated documentationfiles (the "Software"), to deal in the Software withoutrestriction, including without limitation the rights to use,copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom theSoftware is furnished to do so, subject to the followingconditions:The above copyright notice and this permission notice shall beincluded in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIESOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE ANDNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHTHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISINGFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OROTHER DEALINGS IN THE SOFTWARE.*//* © NewLoop Ltd: 020 7702 3130Author Lindsey Fallow: lindz@btinternet.com****************************************************************************                       CLASS DESCRIPTION AND DEFINITION            *                                                     *                      *                                                     *                      *                                                     *                      *                                                     *                      *                                                     *                      *                                                     *                      *                                                     *                      *                                                     *          ****************************************************************************        Code Conventions:        Class        verbMethod        nounProperty        _nounProperty = simple property relating directly to MovieClip properties (height, width etc)        isBoolean        onCallback        _mc = MovieClip        _txt = TextField        _arr = Array        _str = String        tVariableName = temporary variable for calculation or data handling purposes*****************************************************************************/package com.newloop.air{	import com.deng.fzip.FZip;	import com.deng.fzip.FZipErrorEvent;	import com.deng.fzip.FZipEvent;	import com.deng.fzip.FZipFile;	import com.newloop.air.events.AirUpdateManagerEvent;		import flash.display.DisplayObject;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.filesystem.File;	import flash.filesystem.FileMode;	import flash.filesystem.FileStream;	import flash.net.URLLoader;	import flash.net.URLLoaderDataFormat;	import flash.net.URLRequest;	import flash.utils.ByteArray;		import mx.controls.Alert;	import mx.controls.Button;	import mx.events.CloseEvent;			//import mx.controls.Alert;	//import mx.events.CloseEvent;					/**	 * AirUpdateManager handles compulsory and optional updates to Air Applications	 * 	 * <p>The class relies on a remote xml file containing the version information.</p>	 * <p>The structure of the remote xml file is : </p>	 * <p><code>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;<br>	 * &lt;currentVersion&gt;<br>	 * &lt;version&gt;2.2&lt;/version&gt;<br>	 * &lt;downloadLocation&gt;&lt;![CDATA[http://www.yourdomain.com/AIR/UMTest/UM.air]]&gt;&lt;/downloadLocation&gt;<br>     * &lt;forceUpdate&gt;false&lt;/forceUpdate&gt;<br>     * &lt;message&gt;&lt;![CDATA[Added new features]]&gt;&lt;/message&gt;<br>     * &lt;/currentVersion&gt;</code></p>	 * 	 * @author lindseyf	 * 	 */		public class AirResourceUpdateManager extends EventDispatcher	{				private var downloadLocation:String;		private var localPath:String;		private var filename:String;		private var displayTarget:DisplayObject;		private var file:File;		private var zip:FZip;		private var directoryPath:String;		private var targetDirectory:File;		private var isDownloadError:Boolean;						/**		 * Creates a new AirUpdateManager instance.  After creating the AirUpdateManager listen for the AirUpdateManagerEvent events.		 * 		 * @param displayTargetObj - A display object to be used as the container for the alert.		 * @param versionXmlUrl - The path to the version.xml file. 		 * @param isAutoCheck - If true, the update manager performs the check immediately.		 * 		 */				public function AirResourceUpdateManager(displayTargetObj:DisplayObject, directoryPath:String, filename:String, localPath:String, downloadLocation:String, createSymbolicLink:Boolean = true)		{					// localise stuff for PC / Mac						this.displayTarget = displayTargetObj;			this.localPath = localPath;			this.targetDirectory = this.resolvePath("");			this.createRequiredDirectories(directoryPath);			this.targetDirectory = this.resolvePath(directoryPath);			this.filename = filename;			this.downloadLocation = downloadLocation;			this.isDownloadError = false;		}				/**		 * Checks whether the file is already available. 		 * 		 * @param askForDownload - specifies whether to proceed to offer download if the file is not found.		 * @param downloadDialogMessage - message to show the user in offering the file download.		 * 		 * @return Boolean		 */						public function checkForFile(askForDownload:Boolean = true, downloadDialogMessage:String = "Would you like to download this file?"):Boolean{			// resolve the local file path			this.file = this.targetDirectory.resolvePath(this.filename);			//			return false;			if(this.file.exists){				return true;			} else {				if(askForDownload){					this.displayDialog(downloadDialogMessage);					}				return false;			}		}								private function displayDialog(downloadDialogMessage:String):void{			var buttonArray:Array = ["Later", "Download"];			var alertTitle:String = "Download available";			Alert.show("Download now?",alertTitle,Alert.OK|Alert.CANCEL,null,this.alertHandler);//			AlertManager.createAlert(this.displayTarget, downloadDialogMessage, alertTitle, buttonArray, this.alertHandler);					}				private function alertHandler(e:CloseEvent):void{			if(e.detail==Alert.OK){			 	// run the update			 	this.runUpdate();			} else {				// run the handler function				this.cancelUpdate();			}		}						private function runUpdate():void{			var e:AirUpdateManagerEvent = new AirUpdateManagerEvent(AirUpdateManagerEvent.ACCEPT_UPDATE);			this.dispatchEvent(e);			this.downloadFile();		}				private function cancelUpdate():void {			trace("cancelUpdate");						var e:AirUpdateManagerEvent = new AirUpdateManagerEvent(AirUpdateManagerEvent.SKIP_UPDATE);						this.dispatchEvent(e);		}				public function downloadFile():void {			trace("downloading file : " + this.downloadLocation);						var request:URLRequest = new URLRequest(this.downloadLocation);			// always assume the file is a zip even if it doesn't have the proper file extension//			if(this.downloadLocation.split(".").pop() == "zip"){				this.downloadZip(request);				return;//			}						var loader:URLLoader = new URLLoader();			loader.dataFormat = URLLoaderDataFormat.BINARY;			loader.load(request);			loader.addEventListener(Event.COMPLETE, this.writeFileToSystem);			loader.addEventListener(ProgressEvent.PROGRESS, this.updateProgressHandler);			loader.addEventListener(IOErrorEvent.IO_ERROR, this.IOLoaderErrorHandler);		}				private function downloadZip(request:URLRequest):void {			trace("download zip");			this.zip = new FZip();			this.zip.addEventListener(Event.COMPLETE, this.zipCompleteHandler);			this.zip.addEventListener(IOErrorEvent.IO_ERROR, this.IOZipErrorHandler);			this.zip.addEventListener(FZipErrorEvent.PARSE_ERROR, this.parseErrorHandler);			this.zip.addEventListener(ProgressEvent.PROGRESS, this.updateProgressHandler);			this.zip.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.securityErrorHandler);			this.zip.addEventListener(Event.OPEN, defaultHandler);			this.zip.addEventListener(FZipEvent.FILE_LOADED, this.fileLoadedHandler);						this.zip.load(request);		}				private function fileLoadedHandler(e:FZipEvent):void{			var tFile:FZipFile = e.file;			trace("file loaded : " +tFile.filename);			// write file			this.writeZipFileToSystem(tFile);		}				private function defaultHandler(e:Event):void{			trace("defaultHandler : " + e.type);			this.dispatchEvent(e.clone());		}				private function zipCompleteHandler(e:Event):void {			trace("zip complete handler");			//this.writeZipFolderToSystem();			if(!this.isDownloadError){				this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_COMPLETE));			}					}				private function parseErrorHandler(e:Event):void{			this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "Error in zip parsing."));		}				private function IOZipErrorHandler(e:Event):void{			this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "IOError in zip processing."));		}				private function IOLoaderErrorHandler(e:Event):void{			this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "IOError in loader - unable to download files."));		}				private function securityErrorHandler(e:Event):void{			this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "Security error in zip parsing."));		}				private function writeZipFolderToSystem():void{			trace("write zip folder to system");			var stream:FileStream = new FileStream();						var tFolderArr:Array = this.filename.split("/");			tFolderArr.pop();			var folderPath:String = tFolderArr.join("/");						var folderLocation:String = this.localPath + folderPath;			this.file = this.targetDirectory.resolvePath(folderLocation);			trace("writing : " +this.file.nativePath);			try{				// open and write to the file stream				stream.open(this.file, FileMode.WRITE);				this.zip.serialize(stream);				stream.close();				//				this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_COMPLETE));				trace("wrote file");			} catch (error:Error) {				trace('failed to write: ' + error);				this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "Failed to write zip folder to system."));			}		}				private function writeZipFileToSystem(tFile:FZipFile):void{			trace("write zip file to system");			var stream:FileStream = new FileStream();						this.createRequiredDirectories(tFile.filename);						var fileToWrite:File = this.targetDirectory.resolvePath(tFile.filename);			trace("writing : " +fileToWrite.nativePath);			if(fileToWrite.isDirectory){				return;			}			try{				// open and write to the file stream				stream.open(fileToWrite, FileMode.WRITE);				var contentByteArray:ByteArray = tFile.content;				stream.writeBytes(contentByteArray);				stream.close();				//				//if(this.isDownloadComplete){					//this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_COMPLETE));				//}				trace("wrote file");			} catch (error:Error) {				trace('failed to write: ' + error);				this.isDownloadError = true;				this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "Failed to write zip file to system."));			}		}				private function createRequiredDirectories(fileDirectory:String):void{			// recurse through the director path to create any required folders			var directoryArray:Array = fileDirectory.split("/");			// check each exists			var workingDirectory:File = this.targetDirectory;			var iLength:uint = directoryArray.length-1;			for(var i:uint = 0;i<iLength;i++){				trace("working directory : " + workingDirectory.nativePath);				var directoryName:String = directoryArray[i];				trace("directoryName : " + directoryName);				var nextWorkingDirectory:File = workingDirectory.resolvePath(directoryName);				if(nextWorkingDirectory.exists){					if(nextWorkingDirectory.isDirectory){						// do nothing						trace("directory exists");					} else {						// error!						trace("file not a directory");						this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "Expected directory, but path is to a file."));					}				} else {					trace("folder not found");					var newDir:File = File.createTempDirectory();					var nextWorkingDirectoryProxy:File = newDir.resolvePath(directoryName);					nextWorkingDirectoryProxy.createDirectory();					nextWorkingDirectoryProxy.copyTo(nextWorkingDirectory);				}				workingDirectory = nextWorkingDirectory;				trace(workingDirectory.nativePath);			}			//		}						private function writeFileToSystem(e:Event):void {			try {				// get the last bit of the file path - this is the file name				var filename:String = this.downloadLocation.split("/").pop() as String;				var stream:FileStream = new FileStream();				stream.open(this.file, FileMode.WRITE);				stream.writeBytes(e.target.data);				stream.close();				this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_COMPLETE));			} catch (error:Error) {				this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "Failed to write file to system: "+error.message));			}		}				private function updateProgressHandler(e:ProgressEvent):void{						var percentage:Number = Math.round(100*(e.bytesLoaded / e.bytesTotal));			trace("percentage : " + percentage);			this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_PROGRESS,percentage));		}				private function resolvePath(fileOrFolderName:String):File{			var tFile:File;			if( this.localPath == "documentsDirectory"){				tFile = File.documentsDirectory.resolvePath(fileOrFolderName);				} else if (this.localPath == "applicationDirectory"){				tFile = File.applicationDirectory.resolvePath(fileOrFolderName);			} else if(this.localPath == "applicationParentDirectory"){				tFile = File.applicationDirectory;				tFile = tFile.resolvePath("..");				tFile = tFile.resolvePath(fileOrFolderName);			} else if(this.localPath == "applicationStorageDirectory"){				tFile = File.applicationStorageDirectory.resolvePath(fileOrFolderName);			} else if(this.localPath == "desktopDirectory"){				tFile = File.desktopDirectory.resolvePath(fileOrFolderName);			} else if(this.localPath == "userDirectory"){				tFile = File.userDirectory.resolvePath(fileOrFolderName);			} else {				tFile = null;				this.dispatchEvent(new AirUpdateManagerEvent(AirUpdateManagerEvent.DOWNLOAD_ERROR, "Unresolvable folder path."));			}			trace("tFile : " + tFile.nativePath);						return tFile;		}			}}